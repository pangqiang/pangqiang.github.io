---
title: 基础算法-动态规划入门
date: 2023-03-16 21:57:24
tags: 算法
---

# 动态规划

> 动态规划的算法是一种优化技术，它可以将一个复杂的问题分解成若干个子问题，并且利用子问题的最优解来推导出原问题的最优解。动态规划通常需要满足两个条件：最优子结构和无后效性

## 动态规划的两个重要条件

### 最优子结构

最优子结构是指一个问题的最优解可以由其子问题的最优解推导出来，也就是说，如果我们知道了所有的子问题的最优解，那么我们就可以很容易地得到原问题的最优解。

### 无后效性

无后效性是指一个状态一旦确定，就不受之后的状态或者决策的影响。也就是说，我们只需要关心当前的状态，而不需要考虑它是如何产生的，或者它会对未来产生什么影响

举个例子，假设我们要求一个字符串的最长回文子串（即正反读都一样的子串），那么这个问题就具有最优子结构和无后效性。

- 最优子结构：如果我们知道了字符串s[i…j]是否是回文串，那么我们就可以根据s[i]==s[j]和s[i+1…j-1]是否是回文串来判断s[i…j+1]是否是回文串。因此，我们可以从长度为1和2的子串开始判断，并逐渐扩展到更长的子串，直到找到最长的回文子串。

- 无后效性：对于任意一个字符串s[i…j]，它是否是回文串只取决于它本身，而不受前面或者后面的字符或者其他状态的影响。因此，我们只需要记录每个字符串是否是回文串即可，并不需要关心它们之间如何转移。


爬楼梯问题是一个经典的动态规划问题，它可以用以下的描述：¹²³

- 有一个 n 层的楼梯，每次可以选择爬一级或者两级台阶。
- 求有多少种不同的方法可以爬到第 n 层。

这个问题的解法可以用以下的思路：¹²³

- 定义状态：dp[i] 表示爬到第 i 层的方法数。
- 找出状态转移方程：dp[i] = dp[i-1] + dp[i-2]，因为每次只能爬一级或者两级，所以到达第 i 层的方法数等于到达第 i-1 层和第 i-2 层的方法数之和。
- 确定边界条件：dp[0] = 0，dp[1] = 1，dp[2] = 2，因为没有台阶时没有方法，只有一级台阶时只有一种方法，只有两级台阶时有两种方法。
- 计算结果：从小到大依次计算 dp[i] 的值，直到得到 dp[n] 即为最终答案。

用 JavaScript 语言实现这个算法如下：

```javascript
function climbStairs(n) {
    // 初始化状态数组
    let dp = new Array(n+1).fill(0);
    // 边界条件
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 状态转移方程
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

参考网址：

1. [cnblogs.com](https://www.cnblogs.com/icode-girl/p/5312679.html)。
2. [blog.51cto.com](https://blog.51cto.com/u_6468453/6124483)
3. [zhihu.com](https://www.zhihu.com/question/43361359)
4. [blog.csdn.net](https://blog.csdn.net/qq_25800311/article/details/90635979)
5. [bing.com](https://www.bing.com/search?q=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E5%92%8C%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7&toWww=1&redig=0E9313C4E45E4D468016AAA33CB82A8E)

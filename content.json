{"pages":[{"title":"代码，篮球，艺术","text":"代码，篮球，艺术 竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生","link":"/about/index.html"},{"title":"","text":"body{ width: 100%; background: url('../img/bg3-l.jpg'); background-attachment: fixed; background-size: 100% 100%; } /* .full-bg-img .mask{ background-color:transparent } #navbar{ background: rgb(169 155 164); } .banner-text{ color: inherit; } */","link":"/css/custom.css"}],"posts":[{"title":"ChatGPT问答系列 - 递归","text":"🤔 请使用通俗易懂的话解释递归执行的顺序和原理 递归是一种函数调用自身的编程技术。在递归中，函数将问题分解为较小的子问题，并使用相同的函数递归地解决这些子问题。递归执行的顺序和原理如下: 当函数被调用时，它首先执行函数内的代码，直到遇到递归调用。递归调用会使函数重新运行，并创建一个新的局部变量和新的执行环境。 在递归调用中，函数将问题分解为更小的子问题。通常，这些子问题与原始问题具有相同的结构，只是问题规模更小。 当问题被分解为最小规模时，函数将不再进行递归调用，而是直接返回结果。这个返回值会成为之前递归调用的返回值的一部分，直到整个递归过程结束。 当递归结束后，程序将返回到最初的函数调用，继续执行原始函数中的代码。整个递归过程可以看作是一系列嵌套函数调用的堆栈，直到递归结束后，程序会逐步从最深的嵌套函数调用中返回到最初的调用处。总之，递归是一种强大的编程技术，可以帮助我们解决许多复杂的问题。但是，由于递归可能导致无限循环和堆栈溢出等问题，因此需要谨慎使用，并确保递归函数的正确性和效率。 请举一个简单的例子一个经典的递归例子是计算阶乘（factorial）函数。阶乘函数表示将一个正整数 n 乘以小于等于 n 的所有正整数的积。阶乘函数的定义如下： n! = n * (n-1) * (n-2) * ... * 2 * 1 使用递归可以将阶乘函数简洁地实现。下面是一个计算阶乘的递归函数的 Python 代码示例： 12345def factorial(n): if n == 0: # 递归结束条件 return 1 else: return n * factorial(n-1) # 递归调用 在这个函数中，当 n 为 0 时，递归结束，函数返回 1。当 n 大于 0 时，函数执行递归调用，将 n 乘以 factorial(n-1) 的返回值。这个递归调用会一直执行到 n 等于 0，然后逐步返回到之前的递归调用处，最终得到阶乘的结果。例如，factorial(5) 的值为 5 * 4 * 3 * 2 * 1 = 120。 你认为动态规划和递归之间有关系吗 递归通常用于将复杂问题分解成更小的子问题，以便逐步解决。这种方法对于问题的分解和解决非常有效，但也可能导致重复计算。例如，在计算斐波那契数列时，递归算法会多次计算相同的子问题，导致时间复杂度较高。 动态规划则是一种通过将问题分解为重叠的子问题来解决问题的方法，避免了重复计算。动态规划算法通常通过存储子问题的解决方案，以避免重复计算。 动态规划和递归之间的关系在于，动态规划算法通常通过递归来实现，但是在计算过程中，动态规划算法会根据子问题的解决方案来避免重复计算。因此，可以将动态规划看作是一种优化后的递归算法，可以有效地解决复杂问题，同时避免了递归算法中的重复计算问题。 将动态规划看作是一种优化后的递归算法，那具体是怎么优化的呢 动态规划算法是通过将问题分解成更小的子问题，并利用子问题的解来构建问题的解决方案。这种分解问题的方法类似于递归算法，但是动态规划算法中会进行额外的优化，以避免递归算法中的重复计算问题。具体而言，动态规划算法的优化包括以下几个方面： 子问题的重叠性：动态规划算法将问题分解成子问题，并将子问题的解保存下来。在计算下一个子问题的解时，动态规划算法可以利用已经计算过的子问题的解，从而避免重复计算。 最优子结构：动态规划算法将问题分解成子问题，并通过子问题的最优解来构建问题的最优解。这种最优子结构的特性使得动态规划算法能够有效地解决复杂问题。 状态转移方程：动态规划算法通过状态转移方程来描述问题的解决方案。状态转移方程表示当前问题的解决方案与其子问题的解决方案之间的关系。通过利用状态转移方程，动态规划算法可以有效地计算问题的解决方案。 通过这些优化，动态规划算法可以避免递归算法中的重复计算问题，同时具有更高的计算效率和更好的时间复杂度。因此，可以将动态规划看作是一种优化后的递归算法。","link":"/2023/03/19/ChatGPT%E9%97%AE%E7%AD%94%E7%B3%BB%E5%88%97/"},{"title":"JS任意进制之间的转换","text":"JavaScript 进制转换介绍在计算机科学中，进制转换是一种非常基础的操作。在 JavaScript 中，可以使用 parseInt() 和 toString() 方法进行任意进制之间的转换。在本篇文章中，我们将介绍 JavaScript 中进行进制转换的基本方法，并且提供一些示例帮助你更好地理解这些方法。 十进制转换为其他进制使用 toString() 方法可以将十进制数转换为其他进制数。该方法的参数为目标进制数，例如： 1234// 十进制转换为二进制let num = 10;let binary = num.toString(2); // &quot;1010&quot; 在上面的例子中，num 为十进制数 10，我们将其转换为二进制数 1010 其他进制转换为十进制使用 parseInt() 方法可以将其他进制数转换为十进制数。该方法的第一个参数为需要转换的数值，第二个参数为该数值的进制数，例如： 1234// 二进制转换为十进制let binary = &quot;1010&quot;;let num = parseInt(binary, 2); // 10 在上面的例子中，binary 为二进制数 1010，我们将其转换为十进制数 10。 需要注意的是，对于八进制数和十六进制数，需要在字符串前添加前缀 0 或 0x，例如： 1234567// 八进制转换为十进制let octal = &quot;17&quot;;let num = parseInt(octal, 8); // 15// 十六进制转换为十进制let hex = &quot;A1&quot;;let num = parseInt(hex, 16); // 161 在上面的例子中，octal 为八进制数 17，我们将其转换为十进制数 15。hex 为十六进制数 A1，我们将其转换为十进制数 161。 总结核心方法 parseInt() toString()","link":"/2023/03/11/JS%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/"},{"title":"JS基础-逗号运算符（,）","text":"JS基础-逗号运算符（,）今天在在逛知乎时候，看到一个问题 有哪些短小却令人惊叹的 JavaScript 代码？ 文章中有一个回答：统计字符串中相同字符出现的次数。 12345678var arr = 'abcdaabc';var info = arr .split('') .reduce((p, k) =&gt; (p[k]++ || (p[k] = 1), p), {});console.log(info); //{ a: 3, b: 2, c: 2, d: 1 } 写过JS的同学都知道split reduce 都是常用的数组方法，这段代码奇妙的地方就在与 (p[k] = 1), p) 中的逗号运算符。 逗号运算符的定义我们先来看MDN对逗号运算符的定义 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator逗号（,）运算符对它的每个操作数从左到右求值，并返回最后一个操作数的值。这让你可以创建一个复合表达式，其中多个表达式被评估，复合表达式的最终值是其成员表达式中最右边的值。 语法 expr1, expr2, expr3/, …/ 参数 一个或多个表达式，最后一个表达式的返回值会作为当前复合表达式的值。 描述 当你想要在期望一个表达式的位置包含多个表达式时，可以使用逗号运算符。这个运算符最常用的一种情况是：在 for 循环中提供多个参数。逗号运算符与数组、对象和函数参数中的逗号含义完全不同。 示例 假设 a 是一个二维数组，每一维度包含 10 个元素，以下代码通过使用逗号运算符，可以同时递增 i 和递减 j。下面的代码打印一个二维数组中斜线方向的元素： 123for (let i = 0, j = 9; i &lt;= 9; i++, j--) { console.log(`a[${i}][${j}] = ${a[i][j]}`);} 处理后返回 另一个使用逗号运算符的例子是在返回值前处理一些操作。如前所述，逗号运算符只会返回最后一个元素，但其他表达式都会被求值。所以，可以这么做： 123456function myFunc() { let x = 0; return (x += 1, x); // 与 return ++x; 等价} 该回答中，和MDN 中举例的 “处理后返回” 中的示例代码道理是一致的，下面我们详细分析 首先我们将函数以我们大多数时候会写出的代码，重写一下，如下： 1234567891011var info = arr .split('') .reduce(function(p,k){ // k 表示当前操作的元素 if(p[k]){ p[k]++ }else{ p[k]=1 } return p },{}); 上述代码中，if表达式可以使用三元表达式简写，因为我们可以修改上述代码为： 1234567var info = arr .split('') .reduce(function(p,k){ // k 表示当前操作的元素 p[k]++ || (p[k]=1) return p },{}); 上述表达式中，由于逗号运算符只会返回最后一个元素，但其他表达式都会被求值。 我们可以使用逗号表达式改写为： 1234567var info = arr .split('') .reduce(function(p,k){ // k 表示当前操作的元素 return ( p[k]++||(p[k]=1), p) // 等价于p[k]++ || ( p[k]=1) return p },{}); 最后，我们将内联函数的形式改为箭头函数,省略return，便得到了最终代码 12345var info = arr.split('').reduce( (p,k) =&gt; (p[k]++||(p[k]=1),p), {});","link":"/2023/03/26/JS%E5%9F%BA%E7%A1%80-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89/"},{"title":"JS自定义事件","text":"JS 发布订阅模式实现1234567891011// add an appropriate event listenerobj.addEventListener(&quot;cat&quot;, function(e) { e.detail });// create and dispatch the eventvar event = new CustomEvent(&quot;cat&quot;, { detail: { hazcheeseburger: true }});obj.dispatchEvent(event);","link":"/2022/11/26/JS%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/"},{"title":"axios无感刷新token.md","text":"app.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script setup&gt;import instance from './api/service.js'import { onMounted, onBeforeMount, getCurrentInstance,ref } from 'vue';const app = getCurrentInstance()const txt = ref('')const getData = () =&gt; { instance({ method: 'post', url: 'http://localhost:3000/api/data', }) .then(function (response) { txt.value = response.data.age });}&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt; {{ txt }}&lt;/h1&gt; &lt;el-button @click=&quot;getData()&quot;&gt; 请求数据 &lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.logo { height: 6em; padding: 1.5em; will-change: filter;}.logo:hover { filter: drop-shadow(0 0 2em #646cffaa);}.logo.vue:hover { filter: drop-shadow(0 0 2em #42b883aa);}&lt;/style&gt; axios service.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import axios from 'axios';const instance = axios.create({ // 配置 axios 实例});const getToken = () =&gt; { return new Promise(resolve =&gt; { instance({ method: 'post', url: 'http://localhost:3000/api/token', }) .then(function (response) { resolve(response) }); })}let csrfToken = null;let isRefreshing = false;let failedRequests = [];instance.interceptors.request.use((config) =&gt; { // 在请求头中添加 CSRF token if (csrfToken) { config.headers['X-CSRF-TOKEN'] = csrfToken; } return config;});instance.interceptors.response.use( (response) =&gt; { return response; }, (error) =&gt; { // 如果响应状态码为 403，表示 CSRF token 失效了 if (error.response &amp;&amp; error.response.status === 403) { // 如果正在刷新 CSRF token，就将请求缓存起来 if (isRefreshing) { return new Promise((resolve, reject) =&gt; { failedRequests.push({ resolve, reject }); }).then((token) =&gt; { error.config.headers['X-CSRF-TOKEN'] = token; return instance(error.config); }).catch((err) =&gt; { return Promise.reject(err); }); } isRefreshing = true; // 发起新的请求获取新的 CSRF token return new Promise((resolve, reject) =&gt; { instance.get('http://localhost:3000/api/token') .then((response) =&gt; { csrfToken = response.data.csrfToken; isRefreshing = false; // 重新发起之前缓存的请求 failedRequests.forEach((request) =&gt; { request.resolve(csrfToken); }); failedRequests = []; // 在请求头中添加新的 CSRF token，并重新发起请求 error.config.headers['X-CSRF-TOKEN'] = csrfToken; resolve(instance(error.config)); }) .catch((err) =&gt; { isRefreshing = false; // 清空请求缓存 failedRequests.forEach((request) =&gt; { request.reject(err); }); failedRequests = []; reject(err); }); }); } return Promise.reject(error); });export default instance; service.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const express = require('express');const bodyParser = require('body-parser');const fs = require('fs');const app = express();var cors = require('cors')app.use(bodyParser.json());app.use(cors())let count = 0;app.get('/api/token', (req, res) =&gt; { const data = { csrfToken: new Date().getTime() }; setTimeout(()=&gt;{ res.json(data); },3000)});function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive}function getRandomData(jsonFilePath) { const jsonData = JSON.parse(fs.readFileSync(jsonFilePath)); const randomIndex = getRandomInt(0,jsonData.length); return jsonData[randomIndex];}// 示例用法app.post('/api/data', (req, res) =&gt; { const randomData = getRandomData('data.json'); count++ if (count % 2 === 0 || count % 3 === 0) { res.sendStatus(403); } else { res.json(randomData || {'default':'true'}) ; }});app.listen(3000, () =&gt; { console.log('Server listening on port 3000');});","link":"/2023/04/22/axios%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0token/"},{"title":"echart异形柱状图","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;ECharts 折线图示例&lt;/title&gt; &lt;!-- 引入 ECharts.js --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 用于显示折线图的 DOM 节点 --&gt; &lt;div id=&quot;chart&quot; style=&quot;width: 800px; height: 600px;&quot;&gt;&lt;/div&gt; &lt;script&gt; // 初始化 ECharts 实例 var myChart = echarts.init(document.getElementById('chart')); // 指定图表的配置项和数据 var option = { // 设置图表的标题 title: { text: '山峰起伏状数据统计图表' }, // 设置图表的 x 轴 xAxis: { type: 'category', data: ['一月', '二月', '三月', '四月', '五月', '六月'] }, // 设置图表的 y 轴 yAxis: { type: 'value' }, // 设置图表的数据系列 series: [{ name: '数据', type: 'line', // 设置数据 data: [820, 932, 901, 934, 1290, 1330, 1320], // 设置线条样式 lineStyle: { width: 3, color: 'green' }, // 设置区域填充样式 areaStyle: { color: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'white' // 0% 处的颜色 }, { offset: 0.5, color: 'lightgreen' // 50% 处的颜色 }, { offset: 1, color: 'green' // 100% 处的颜色 }], globalCoord: false // 缺省为 false } } }] }; // 使用刚指定的配置项和数据显示图表 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2023/04/22/echarts-1/"},{"title":"ios手机端使用最新bing","text":"1 申请新bing候补资格申请网址：[ https://www.microsoftedgeinsider.com/zh-cn/download/dev ] 个人经验：全程挂梯子并且使用谷歌邮箱似乎通过的很快，我本人是一天左右通过的 2 使用美区ID 在appStore中下载bing 个人经验：bing有3个版本：国际版，中国版，针对中国的国际版。我们需要的是真正的国际版，因此需要去美区下载 3 bing下载成功后，进行以下三步设置 手机设置中，地区设置为美国 科学上网工具代理地址同样选择到美国 bing APP中地址也同样选择到美国 4 成功使用bing","link":"/2023/03/12/ios%E6%89%8B%E6%9C%BA%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0bing/"},{"title":"NodeJS截取视频第一帧","text":"NodeJS截取视频第一帧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const express = require('express');const app = express();const multer = require('multer');const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;const ffmpeg = require('fluent-ffmpeg');const path = require('path');// 设置ffmpeg的路径ffmpeg.setFfmpegPath(ffmpegPath);// 设置上传文件的存储位置const storage = multer.diskStorage({ destination: (req, file, cb) =&gt; { cb(null, './uploads'); // 上传的文件存储在 uploads 目录中 }, filename: (req, file, cb) =&gt; { cb(null, file.fieldname + '-' + Date.now() + path.extname(file.originalname)); // 给上传的文件命名 }});// 创建上传中间件const upload = multer({ storage });// 定义接口，使用upload中间件解析上传的文件app.post('/upload', upload.single('video'), (req, res) =&gt; { // 获取上传的视频文件的路径 const videoPath = req.file.path; // 调用FFmpeg的ffprobe命令获取视频信息 ffmpeg.ffprobe(videoPath, (err, metadata) =&gt; { if (err) { console.error(err); return; } // 获取视频的第一帧 const screenshotPath = './uploads/screenshot.jpg'; ffmpeg(videoPath) .screenshots({ count: 1, folder: './uploads', filename: 'screenshot-%i.jpg', size: metadata.streams[0].resolution, }) .on('end', () =&gt; { console.log('截取第一帧成功'); // 将视频文件路径和封面图路径返回给前端 res.json({ videoPath, screenshotPath }); }) .on('error', (err) =&gt; { console.error('截取第一帧失败：', err); res.status(500).json({ message: '截取第一帧失败' }); }); });});// 启动服务器app.listen(3000, () =&gt; { console.log('服务器已启动');});","link":"/2023/04/22/nodejs%E8%8E%B7%E5%8F%96%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E7%AC%AC%E4%B8%80%E5%B8%A7/"},{"title":"ElementUI menu组件手动获取indexPath","text":"动态加载的菜单数据，如何不触发select Menu Events获取indexPath背景业务开发中，需要实现一个右键在新页面打开当前所选菜单功能，并且新页面打开后，需要高亮选中之前右键点击的那个菜单。因为菜单可配置，数量无法预估，因此菜单的加载被设计成动态加载，触发条件为鼠标移入当前父级菜单才会去加载子级菜单，由此，也导致新打开的页面，菜单并没有子数据，所以就算是我们记录了之前点击的具体的某一次子菜单，我们也无法选中，想要选中，必须某一级的菜单链上的菜单数据在页面加载完成时，菜单数据也需要被加载，蠢办法是菜单数据在请求时全量加载，但显然不，这不是一个优雅的解决办法（: 那么比较优雅的解决办法是什么呢？ 答案是：回显选中，我们只需要 所选菜单整个链上 的数据即可，也就是indexpath记录的数组中的对应的菜单数据。 那么我们就需要知道某一个选中的菜单indexPath,通常indexpath的值是每一级数据的ID，例如[1xxxx, 2xxxx, 3xxxx], 我们通过后台接口，查出整个indexPath链上的数据。 如何获取 indexPath？Element 的menu组件中 Menu Events 板块中，提供了 select 事件，我们在点击菜单时候，会触发select 事件，回调参数中的第二个参数便是indexpath，但是，我们右键点击菜单时，并不会触发select ，那么如何在右键点击时候获取到 indexpath呢？ https://element-plus.gitee.io/zh-CN/component/menu.html#menu-events 通常 ，我们可能会想到，在右键点击的时候，去主动触发一次左键点击事件，但是一般情况，我们左键点击都绑定着具体的业务逻辑，我们手动触发，势必是要在左键触发的逻辑中做适配，否则就会影响原有逻辑，我们希望的是能不影响任何原有逻辑的情况，有一个单纯获取indexpath的方法，方法如下 （来自ElementUI源码）： 组合式写法如下，基于setup 1234567891011const indexPath = computed(() =&gt; { let parent = instance.parent! const path = [currentIndex.value] while (parent.type.name !== 'ElMenu') { if (parent.props.index) { path.unshift(parent.props.index as string) } parent = parent.parent! } return path}) 选项式写法如下 1234567891011const indexPath = computed(() =&gt; { let parent = instance.$parent // instance 为当前组件，options写法中，通过 this.$refs 获取 const path = [currentIndex] // currentIndex 为当前点击的菜单的 index while (parent.$options.name !== 'ElMenu') { if (parent.$options.index) { path.unshift(parent.$options.index) } parent = parent.$parent } return path})","link":"/2023/04/09/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%8F%9C%E5%8D%95%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8D%E8%A7%A6%E5%8F%91select-Menu-Events%E8%8E%B7%E5%8F%96indexPath/"},{"title":"基础算法-动态规划入门","text":"动态规划 动态规划的算法是一种优化技术，它可以将一个复杂的问题分解成若干个子问题，并且利用子问题的最优解来推导出原问题的最优解。动态规划通常需要满足两个条件：最优子结构和无后效性 动态规划的两个重要条件最优子结构最优子结构是指一个问题的最优解可以由其子问题的最优解推导出来，也就是说，如果我们知道了所有的子问题的最优解，那么我们就可以很容易地得到原问题的最优解。 无后效性无后效性是指一个状态一旦确定，就不受之后的状态或者决策的影响。也就是说，我们只需要关心当前的状态，而不需要考虑它是如何产生的，或者它会对未来产生什么影响 举个例子，假设我们要求一个字符串的最长回文子串（即正反读都一样的子串），那么这个问题就具有最优子结构和无后效性。 最优子结构：如果我们知道了字符串s[i…j]是否是回文串，那么我们就可以根据s[i]==s[j]和s[i+1…j-1]是否是回文串来判断s[i…j+1]是否是回文串。因此，我们可以从长度为1和2的子串开始判断，并逐渐扩展到更长的子串，直到找到最长的回文子串。 无后效性：对于任意一个字符串s[i…j]，它是否是回文串只取决于它本身，而不受前面或者后面的字符或者其他状态的影响。因此，我们只需要记录每个字符串是否是回文串即可，并不需要关心它们之间如何转移。 爬楼梯问题是一个经典的动态规划问题，它可以用以下的描述：¹²³ 有一个 n 层的楼梯，每次可以选择爬一级或者两级台阶。 求有多少种不同的方法可以爬到第 n 层。 这个问题的解法可以用以下的思路：¹²³ 定义状态：dp[i] 表示爬到第 i 层的方法数。 找出状态转移方程：dp[i] = dp[i-1] + dp[i-2]，因为每次只能爬一级或者两级，所以到达第 i 层的方法数等于到达第 i-1 层和第 i-2 层的方法数之和。 确定边界条件：dp[0] = 0，dp[1] = 1，dp[2] = 2，因为没有台阶时没有方法，只有一级台阶时只有一种方法，只有两级台阶时有两种方法。 计算结果：从小到大依次计算 dp[i] 的值，直到得到 dp[n] 即为最终答案。 用 JavaScript 语言实现这个算法如下： 1234567891011121314151617function climbStairs(n) { // 初始化状态数组 let dp = new Array(n+1).fill(0); // 边界条件 if (n == 0) return 0; if (n == 1) return 1; if (n == 2) return 2; // 状态转移方程 dp[0] = 0; dp[1] = 1; dp[2] = 2; for (let i = 3; i &lt;= n; i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n];} 参考网址： cnblogs.com。 blog.51cto.com zhihu.com blog.csdn.net bing.com","link":"/2023/03/16/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"},{"title":"基础算法-滑动窗口","text":"滑动窗口的经典题目滑动窗口是一种常用的算法思想，常用于解决一些与连续区间相关的问题。下面是两道经典的滑动窗口题目’1. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。 解题思路： 维护一个滑动窗口，记录窗口左右端点的位置 left 和 right。初始化 left = right = 0，sum = 0，用 sum 记录窗口中元素的和。然后不断移动右端点，直到窗口中元素的和大于等于 s。此时记录一下窗口的长度，然后移动左端点，缩小窗口的范围，直到窗口中元素的和小于 s。这个过程中不断更新窗口的长度，最后输出最小的长度即可。 代码实现 1234567891011121314151617181920function minSubArrayLen(s, nums) { let left = 0, right = 0; sum = 0, ans = Infinity; const len = nums.length; while (right &lt; len) { sum += nums[right]; // 取最小值过程 while (sum &gt;= s) { ans = Math.min(ans, right - left + 1); sum -= nums[left]; left++; } right++ } if (ans === Infinity) { return 0; } else { return ans; }} 2. 最长连续递增序列 给定一个未经排序的整数数组，找到最长的连续递增序列（子数组）的长度。 示例： 输入: [1,3,5,4,7] 输出: 3 解释: 最长连续递增序列是 [1,3,5], 长度为3。 解题思路： 维护一个滑动窗口，记录窗口左右端点的位置 left 和 right。初始化 left = right = 0，max_len = 1，用 max_len 记录最长连续递增序列的长度。然后不断移动右端点，如果当前元素比前一个元素大，说明当前元素可以加入到递增序列中，此时更新 max_len。如果当前元素比前一个元素小，说明递增序列已经断开，更新 left 的位置为 right，重新开始寻找递增序列。 代码实现 1234567891011121314151617function findLengthOfLCIS(nums){ const len = nums.length; if(len === 0){ return 0; } let left = 0,right = 0 let max_len = 1 while( right&lt;len ){ if(right&gt;0 &amp;&amp; nums[right] &gt; nums[right-1]){ max_len = max(max_len, right - left + 1) }else{ left = right right += 1 } } return max_len} 3. 最多颜色的车辆 题目描述 在一个狭小的路口，每秒只能通过一辆车，假设车辆的颜色只有 3 种，找出 N 秒内经过的最多颜色的车辆数量。 三种颜色编号为0 ，1 ，2 输入描述 第一行输入的是通过的车辆颜色信息 [0,1,1,2] 代表4 秒钟通过的车辆颜色分别是 0 , 1 , 1 , 2 第二行输入的是统计时间窗，整型，单位为秒 输出描述 输出指定时间窗内经过的最多颜色的车辆数量。 输入 0 1 2 1 3 输出 2 123456789101112131415161718192021222324252627282930313233343536373839404142const _arr = [0,1,2,1]const t = 2;function carNums( arr,n){ let l = 0; let r = l + n; let max_0_t = 0 let max_1_t = 0 let max_2_t = 0 const len = arr.length; while( r &lt;= len ){ const temp = arr.slice(l,r) let map = { '0':0, '1':0, '2':0 } for(let i= 0; i &lt; temp.length; i++){ const item = temp[i]; if( item === 0 ){ map['0'] ++ } if( item === 1 ){ map['1'] ++ } if( item === 2 ){ map['2'] ++ } } max_0_t = Math.max(map[0],max_0_t); max_1_t = Math.max(map[1],max_1_t); max_2_t = Math.max(map[2],max_2_t); l ++ r= l + n } return Math.max(max_0_t,max_1_t,max_2_t)}console.log( carNums(_arr,t)); // 思考滑动窗口算法，核心是要写出窗口左右移动的条件","link":"/2023/03/13/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"本地调试element-plus源码正确方式","text":"本地调试 element-plus 的源码，可以按照以下步骤进行element-plus使用 yarn 和 pnpm 管理代码，已安装，直接执行第三步。未安装, 请先安装yarn 和 pnpm1. 安装 yarn1npm install -g yarn 2. 安装 pnpm1npm install -g pnpm 3. 准备调试在控制台执行如下步骤 12345git clone &lt;https://github.com/element-plus/element-plus.git&gt;cd element-pluspnpm installyarn dev 4. 浏览器打开已启动的本地服务","link":"/2023/04/02/%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95element-plus%E6%BA%90%E7%A0%81%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F/"},{"title":"递归遍历菜单结构","text":"递归遍历菜单结构","link":"/2023/04/01/%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E8%8F%9C%E5%8D%95%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ChatGPT问答系列","slug":"ChatGPT问答系列","link":"/tags/ChatGPT%E9%97%AE%E7%AD%94%E7%B3%BB%E5%88%97/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"JS基础","slug":"JS基础","link":"/tags/JS%E5%9F%BA%E7%A1%80/"},{"name":"axios,js","slug":"axios-js","link":"/tags/axios-js/"},{"name":"经验","slug":"经验","link":"/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"ElementUI技巧","slug":"ElementUI技巧","link":"/tags/ElementUI%E6%8A%80%E5%B7%A7/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"坑","slug":"坑","link":"/tags/%E5%9D%91/"}],"categories":[]}